<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lybvinci.github.io</id>
    <title>Lybvinci&apos;s blob</title>
    <updated>2019-06-12T13:18:25.721Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lybvinci.github.io"/>
    <link rel="self" href="https://lybvinci.github.io/atom.xml"/>
    <subtitle>学而不思则罔，思而不学则殆。</subtitle>
    <logo>https://lybvinci.github.io/images/avatar.png</logo>
    <icon>https://lybvinci.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Lybvinci&apos;s blob</rights>
    <entry>
        <title type="html"><![CDATA[如何获取安卓 framework 源码]]></title>
        <id>https://lybvinci.github.io/post/ru-he-huo-qu-an-zhuo-framework-yuan-ma</id>
        <link href="https://lybvinci.github.io/post/ru-he-huo-qu-an-zhuo-framework-yuan-ma">
        </link>
        <updated>2019-06-12T13:12:31.000Z</updated>
        <summary type="html"><![CDATA[<p>最近由于工作需要，需要反编译获取安卓 Q framework 层的源码。然而安卓Q的源码按照历史的方式去反编译，都不成功。但是通过这次尝试，也初次学到了如何反编译安卓源码。下面就做一些记录。(文中都是依照安卓9.0举例。)</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近由于工作需要，需要反编译获取安卓 Q framework 层的源码。然而安卓Q的源码按照历史的方式去反编译，都不成功。但是通过这次尝试，也初次学到了如何反编译安卓源码。下面就做一些记录。(文中都是依照安卓9.0举例。)</p>
<!-- more --> 
<h1 id="通过系统安装包">通过系统安装包</h1>
<p>这种方式，首先要求你能获取到系统的安装包。一般都是一个 zip 包，去官网就能下载到，此处不再赘述。解压完zip 包，可以看到里面还有一个 zip 压缩包，一般是 <em>image</em> 开头。接着把这个zip包进行一次解压，可以看到里面有很多以 *<em>.img</em> 结尾的文件，我们关注的 framework 层的代码就都在这个 system.img 里面。此时就需要 <a href="https://www.mediafire.com/file/gjy2a57k33b4vpa/simg2img">simg2img</a> 工具出场了。</p>
<pre><code class="language-shell">simg2img system.img system.ext4.img(自定义的输出文件名,后续都用这个文件名.) 
</code></pre>
<p>因为 system.img 是谷歌自己定义的一个格式，通过 file 命令可以查看:</p>
<pre><code class="language-shell">$ file system.img
system.img: Android sparse image, version: 1.0, Total of 202229 4096-byte output blocks in 15 input chunks
</code></pre>
<p>必须通过 simg2img 命令进行转换，才能变成真正的 ext4 的镜像。然后就可以进行挂载了。</p>
<h2 id="mac">mac</h2>
<p>mac上你必须安装 <a href="https://osxfuse.github.io/">fuse</a>,之后再通过 brew 安装 ext4fuse.</p>
<pre><code class="language-shell">brew cask install osxfuse	
</code></pre>
<p><strong>注意：</strong> 安装完成必须重启。否则命令无论如何也不会生效。如果运行时报错说版本不匹配，那么最好的方式就是卸载重装。</p>
<p>一切准备就绪之后，就可以通过如下命令：</p>
<pre><code>mkdir system //文件夹名称随便起名
ext4fuse ./system.ext4.img ./system -o allow_other
</code></pre>
<p>如果一切顺利，你就可以在system文件夹看到想要镜像里面的内容了。</p>
<h2 id="linux">linux</h2>
<p>linux 上比较容易,为了避免失败，最好按照只读的方式去挂载。</p>
<pre><code class="language-shell">$ sudo mount -t ext4 -o ro,loop system.ext4.img ./system/  //ro 表示只读
$ ls system
$ ls
acct  bin         cache    config  data           default.prop  dsp  firmware  init.environ.rc  init.usb.configfs.rc  init.zygote32.rc     lost+found  mnt  oem      postinstall  product           res   sdcard   sys     ueventd.rc
apex  bugreports  charger  d       debug_ramdisk  dev           etc  init      init.rc          init.usb.rc           init.zygote64_32.rc  metadata    odm  persist  proc         product_services  sbin  storage  system  vendor
</code></pre>
<p>接下来就是如何去解oat,vdex了。</p>
<h1 id="直接从手机获取">直接从手机获取</h1>
<p>上面说的挂载镜像，实际就相当于把系统安装起来，那么手机不就是现成的已经安装好的系统吗？所以只需要通过adb 命令就能直接从手机里面提取所需的文件。(无需 root 即可获取)</p>
<pre><code>adb pull /system/framework/arm64/boot-framework.vdex ./
</code></pre>
<p>每个安卓版本都不一样，此处说的是9.0.之前的版本是怎么样的，请参考<a href="%5Bhttp://wuxianlin.com/2019/03/22/android-reverse-engineering/#more%5D(http://wuxianlin.com/2019/03/22/android-reverse-engineering/#more)">这篇文章</a>。</p>
<h1 id="反编译-vdex-文件">反编译 vdex 文件</h1>
<p>获取了文件之后，接下来就是进行反编译。此处祭出神器 <a href="https://github.com/anestisb/vdexExtractor">vdexExtractor</a>, clone 工程，然后在本地进行编译。得到 bin/vdexExtractor 工具，执行：</p>
<pre><code class="language-shell">$ vdexExtractor -i boot-framework.vdex
$ ls *.cdex
boot-framework_classes.cdex  boot-framework_classes2.cdex boot-framework_classes3.cdex
</code></pre>
<p>得到了三个 cdex 文件。本来执行完就是最终的 dex 文件了，但是9.0又加了一层 cdex ,好吧，只好再拿出另一个工具，<a href="https://github.com/linusyang92/mipay-extract/tree/master/tools/cdex">compact_dex_converter</a>, 来将cdex 转换为 dex.</p>
<pre><code class="language-shell">$ mkdir cdexout  // 转换结果的输出目录
$ ./bin/compact_dex_converter -w cdexout ./boot-framework_classes.cdex
</code></pre>
<p>这样在 cdexout 目录，就能看到最终的 dex 文件了。虽然他们还是 cdex 结尾的文件，实质却已经是 dex 文件了。手动进行一下改名，就可以通过 jd-gui 或者 jade 工具查看了。</p>
<h1 id="遗憾">遗憾</h1>
<p>遗憾的是安卓 Q 目前还并不支持。所有的工具目前都无法正常解析，版本无法成功匹配。只有等真正的源码出来之后，再做进一步处理了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ArrayList浅析]]></title>
        <id>https://lybvinci.github.io/post/arraylist-qian-xi</id>
        <link href="https://lybvinci.github.io/post/arraylist-qian-xi">
        </link>
        <updated>2019-06-02T11:10:28.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="0x00-前言">0x00 前言</h2>
<p>大家好，我是 ArrayList， 应该是大家都耳熟能详的容器之一了。学习一下内中原理，还是很有必要的。至于为什么叫浅析呢，因为本文不会分析 Arrays 的相关方法。为什么不分析 Arrays 的相关方法，就是浅析了呢？那就接着往下看~（本文分析源码基于<code>jdk1.8</code>。本文基于第一人称描述，我 == ArrayList。）</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="0x00-前言">0x00 前言</h2>
<p>大家好，我是 ArrayList， 应该是大家都耳熟能详的容器之一了。学习一下内中原理，还是很有必要的。至于为什么叫浅析呢，因为本文不会分析 Arrays 的相关方法。为什么不分析 Arrays 的相关方法，就是浅析了呢？那就接着往下看~（本文分析源码基于<code>jdk1.8</code>。本文基于第一人称描述，我 == ArrayList。）</p>
<!-- more --> 
<h2 id="0x01-一句话介绍">0x01 一句话介绍</h2>
<p>我实际上就是一个可以自动扩容的数组，并可以进行增删改查等操作。</p>
<h2 id="0x02-概述">0x02 概述</h2>
<p>我是<code>list</code>接口的一个可扩容实现。通过 Java 的泛型机制，我可以容纳任何类型的对象。我和 <code>Vector</code> 非常像，但我是线程不安全的，而他是线程安全的，其他地方的差异很小。</p>
<p>我所有方法中，时间复杂度为O(1)的有：</p>
<ul>
<li>size</li>
<li>get</li>
<li>isEmpty</li>
<li>set</li>
<li>iterator</li>
<li>listIterator
而<code>add</code>方法是O(n)的。</li>
</ul>
<p>我的每个实例，都有一个<code>capacity</code>变量。那么这个变量是干嘛的呢？这个变量用于衡量我内在的数组用来装变量的长度，他总是大于等于 size 。当添加一个元素到我这里，他会自动的增长，以满足需要。</p>
<p>如果一个应用他需要往我这里放置很多的元素，那最好一开始就设置我的 ensureCapacity 变量，这样我一开始就申请很多的空间，而不用我一次次扩容浪费时间了。</p>
<p><code>请注意，我不是线程安全的！</code>如果多个线程同时修改我，一个要设置同步，否则会出现数据错误的情况，这个锅，我是不背的。简单的方式就是用<code>Collections#synchronizedList</code>来包装一下我，我就变成一个同步的容器了。</p>
<p>我同样拥有<code>fail-fast</code>机制，如果你迭代我，同时又修改我，我就会抛出<code>ConcurrentModificationException</code>异常，让你承受。多线程同时修改迭代，也会出现这个问题。</p>
<h2 id="0x03-解释几个变量">0x03 解释几个变量</h2>
<h4 id="private-static-final-int-default_capacity-10">private static final int DEFAULT_CAPACITY = 10</h4>
<p>默认的数组大小。</p>
<h4 id="private-static-final-object-defaultcapacity_empty_elementdata">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}</h4>
<p>如果构造我时，采用的是默认的 capacity ，就使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 来当做默认的空数组。</p>
<h4 id="private-static-final-object-empty_elementdata">private static final Object[] EMPTY_ELEMENTDATA = {}</h4>
<p>capacity == 0 ，则使用 EMPTY_ELEMENTDATA 来当做默认的空数组。此时，产生了一个疑问，为什么要弄两个这样的变量呢？后面我们在扩容的时候可以看到，他们是用来区分到底是被设置了 capacity 是 0 ，还是使用了默认的 capacity。那区分这个干嘛呢？那就往下看看扩容是怎么扩的。</p>
<h4 id="transient-object-elementdata">transient Object[] elementData</h4>
<p>先解释一下 <code>transient</code> 这个，这个主要是让此变量不进行序列化。更多的可以谷歌一下，看看详解，此处就略过了。这个就是我的核心部件，我所有的元素都放在他里面！实质就是一个 Object 数组！</p>
<h4 id="private-int-size">private int size</h4>
<p>想要知道我里面到底有多少个元素？喏，size 就是我所拥有的元素数量。</p>
<h2 id="0x04-方法分析">0x04 方法分析</h2>
<h3 id="构造函数分析">构造函数分析</h3>
<pre><code>// 拥有设置 capacity 参数的构造函数
public ArrayList(int initialCapacity) {
    if (initialCapacity &gt; 0) {  // 如果设置的 initialCapacity 初始值大于0，那我的数组就初始相应的长度
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) { 
        // 如果设置了 0 ，那就用 EMPTY_ELEMENTDATA 来初始化我的数组。
        this.elementData = EMPTY_ELEMENTDATA;
    } else { // 小于 0 ，抛出异常
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    }
}

// 无参构造
public ArrayList() {
    // 直接用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 来初始化我的数组。
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
// 还有其他构造函数，此处略去不讲。
</code></pre>
<h3 id="size">size()</h3>
<p>此方法用于查看我有多少个元素，来看看实现。</p>
<pre><code>public int size() {
    // 非常简单，就是返回 size 变量。
    return size;
}
</code></pre>
<h3 id="getint-index">get(int index)</h3>
<p>get 方法用来返回指定索引处的元素。</p>
<pre><code>public E get(int index) {
    // 检查索引是否越界
    rangeCheck(index);
    // 直接根据索引返回元素
    return elementData(index);
}

private void rangeCheck(int index) {
    // 可以看到，如果索引大于等于 size，将会抛出异常。所以在使用时一定要注意不能传入错误的索引，导致程序异常。
    if (index &gt;= size)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}
</code></pre>
<h3 id="setint-index-e-element">set(int index, E element)</h3>
<p>这个方法相当于修改操作。</p>
<pre><code>public E set(int index, E element) {
    // 检查边界
    rangeCheck(index);
    // 先拿到老的元素
    E oldValue = elementData(index);
    // 对应位置附上新元素
    elementData[index] = element;
    // 返回老元素。所以 set 方法的返回是对应的旧元素。
    return oldValue;
}
</code></pre>
<h3 id="adde-e">add(E e)</h3>
<p>这个方法相当于增加操作。</p>
<pre><code>public boolean add(E e) {
    // 确保数组空间充足
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    // 将元素放到原数组长度后面一位。
    elementData[size++] = e;
    return true;
}
private void ensureCapacityInternal(int minCapacity) {
    // 这里使用了 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 。
    // 这个变量是在我初始化时，使用了默认的 capacity 的时候，用来初始化数组的。
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        // 在这种情况下， 将入参和 默认 capacity 进行比较，取其较大大者。
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    // 根据上面的操作，决定了使用什么长度来扩容。下面来进行扩容。
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    // 如果会执行这个操作，就代表会改变数组，则将改变标志位+1.
    modCount++;

    // 原文注释这里说可能会有内存溢出
    if (minCapacity - elementData.length &gt; 0) // 如果大于数组长度，则进行扩容。
        grow(minCapacity);
}

// 我内部的数组最大可以这么大，为什么减了个8呢？因为有些VM底层实现，保留了一些内部字段，致使留给用户的长度就变小了。
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

private void grow(int minCapacity) {
    // 要注意是否会溢出。
    // 先保存数组的原长度。
    int oldCapacity = elementData.length;
    // 新长度是原长度的1.5倍。（右移相当于除以2，所以加起来是1.5倍）
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0) // 如果新长度小于入参长度，则新长度赋值为入参长度。
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 如果新长度大于数组最大长度，则调用 hugeCapacity 方法获取长度。
        newCapacity = hugeCapacity(minCapacity);
    // 调用了 Arrays 的方法，对数组进行了一个复制。
    // 底层就不解释了，可以简单理解为把原 elementData 数组中的值，一个个都搬移到了新的长度为 newCapacity 的数组中，然后让 elementData 指向新数组。
    //（由于没有解析 Arrays.copy 方法，所以本文只能算浅析，后面相关操作，也不会进行解析。要解析的话，一篇文章可能就放不下了。以后专开文章介绍这些工具类。）
    elementData = Arrays.copyOf(elementData, newCapacity);
}

private static int hugeCapacity(int minCapacity) {
    if (minCapacity &lt; 0) // 如果 传递进来的参数小于0，则直接抛异常，此时数组已经放不下了。
        // 什么时候会小于0呢？可以看到参数是通过 index + 1 传递进来的，当index 已经到达了 Integer.MAX_VALUE，则会出现此情况。
        throw new OutOfMemoryError();
    // 发现参数比设置的最大长度还要大，那行吧，那就返回最大值，不然就直接返回最大的数组长度。
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}
</code></pre>
<h3 id="addint-index-e-element">add(int index, E element)</h3>
<p>这个方法实际上是一个插入操作。</p>
<pre><code>public void add(int index, E element) {
    // 范围检查
    rangeCheckForAdd(index);

    // 容量检查
    ensureCapacityInternal(size + 1);  // modCount增加了
    // 直接调用了 System.arraycopy 方法。
    // 这里也不去分析他底层的源码，去分析也不太容易，他实际上是一个 native 方法，要看只能去看 jni 层的代码了。
    // 解释一下现在参数所表示的意思：就是将数组根据传入的 index 分成两部分，然后把后面一部分往后面整体移动一个位置，index位置留出空位。
    // 第一个参数表示源数组
    // 第二个参数表示从哪个位置开始复制
    // 第三个参数表示复制到哪个数组中
    // 第四个参数表示复制从哪里开始
    // 第五个参数表示复制多少位
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index);
    // 将 index 位置进行填充
    elementData[index] = element;
    // 长度自增
    size++;
}
举个🌰解释一下 System.arraycopy 的操作。
有一个数组如下：
[0,1,2,3,4,5,6,null,null,null]
现在如果要在第二位插入一个数字7.
第一步：找到第2个位置，是2；
第二步：把第二位开始的字段整体往后迁移一位，变成：[0,1,2,2,3,4,5,6,null,null]
此时数组已经移动完毕，再进行赋值即可。
</code></pre>
<p>通过源码的分析，可以看到插入实际上是先对数组进行复制移动，耗费巨大。所以应当避免此操作。</p>
<h3 id="removeint-index">remove(int index)</h3>
<p>此即删除操作。</p>
<pre><code>public E remove(int index) {
    // 边界检查
    rangeCheck(index);
    // 修改计数
    modCount++;
    // 找到旧值
    E oldValue = elementData(index);
    // 计算需要移动多少个元素。
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        // 和 上面的 add 操作调用，如出一辙。
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // 利于内存回收
    // 返回旧值
    return oldValue;
}
</code></pre>
<p>可以发现，删除操作也比较费劲，除非是最后一个元素。</p>
<h3 id="removeobject-o">remove(Object o)</h3>
<p>删除指定元素，可以想象，肯定是一个个的遍历然后对比，再执行删除操作。</p>
<pre><code>public boolean remove(Object o) {
    // null 和 非 null 分开处理，私以为，直接使用 Objects.equals 方法不就好了么。
    if (o == null) {
        for (int index = 0; index &lt; size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index &lt; size; index++)
            // 可以看到他调用的是 equals 方法，然而没有调用 == 来判断是否是同一个对象。
            // 所以此处要注意，如果重写了 equals 方法，则同一个对象未必相等。这里可能就识别不到。
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}
// 这个方法和 remove 的上一个方法里面的内容一模一样，不知道上个 remove 方法不用。
private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work
}
</code></pre>
<h3 id="clear">clear()</h3>
<p>清空此 list。</p>
<pre><code>public void clear() {
    modCount++;

    // 挨个赋值 null
    for (int i = 0; i &lt; size; i++)
        elementData[i] = null;

    size = 0;
}
</code></pre>
<h3 id="containsobject-o-indexofobject-o">contains(Object o) &amp;&amp; indexOf(Object o)</h3>
<p>为什么这两个方法放在一起呢，因为他们之间是好基友的关系。</p>
<pre><code>public boolean contains(Object o) {
    // 可以看到，直接调用的 indexOf 方法。
    return indexOf(o) &gt;= 0;
}

public int indexOf(Object o) {
    // 还是将 null 和 非 null 进行了区分处理。是不是似曾相识的代码！remove 不也这么做的么！
    if (o == null) {
        for (int i = 0; i &lt; size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i &lt; size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}
</code></pre>
<p>所以可以看到， contains 和 indexOf 实际上都是对数组进行一个遍历操作，所以使用一定要谨慎。而 Set 方法的 contains 方法是直接用的 hash 计算的，复杂度是 O(1).所以尽量用 Set 进行类似操作。</p>
<h3 id="sublistint-fromindex-int-toindex">subList(int fromIndex, int toIndex)</h3>
<p>从字面上看，他就是返回一个我的孩子 list。</p>
<pre><code>public List&lt;E&gt; subList(int fromIndex, int toIndex) {
    // 边界检查
    subListRangeCheck(fromIndex, toIndex, size);
    // 返回一个 SubList 类！竟然不是 ArrayList
    return new SubList(this, 0, fromIndex, toIndex);
}

看看内部类 SubList 的声明：
private class SubList extends AbstractList&lt;E&gt; implements RandomAccess
和 ArrayList 竟然不一样。
那就看看构造函数吧：

SubList(AbstractList&lt;E&gt; parent,
        int offset, int fromIndex, int toIndex) {
    // parent 当然就是我咯，ArrayList
    this.parent = parent;
    // 相对我的偏移量，就是孩子是从哪开始截取的
    this.parentOffset = fromIndex;
    // 如果儿子也要生儿子，就是产生SubList，则要计算相对爷爷的偏移量，此值就是为了来计算这个。
    // 如果要生重孙子，那就要计算相对于祖爷爷的偏移量。子子孙孙无穷尽也。
    this.offset = offset + fromIndex;
    // 计算孩子有多长。
    this.size = toIndex - fromIndex;
    // 继承父亲的更改计数。
    this.modCount = ArrayList.this.modCount;
}
看一下 SubList 方法的 get 方法。
public E get(int index) {
    // 检查边界
    rangeCheck(index);
    // 检查是否已经被修改
    checkForComodification();
    // 吃惊吗？竟然直接修改的是父亲的数组。
    return ArrayList.this.elementData(offset + index);
}
private void checkForComodification() {
    // 和父亲的修改计数进行一个对比，如果父亲变了，则抛出异常。
    if (ArrayList.this.modCount != this.modCount)
        throw new ConcurrentModificationException();
}
......
</code></pre>
<p>可以看到，SubList 实际上并不是拿到了一个和原数组完全分离的数组，对于 SubList 的修改，全都会作用于父亲这里。这就好比儿子惹得祸，父亲都要来背。所以使用此方法一定要注意。同理，生儿子也要慎重！哈哈。</p>
<h3 id="其他方法就先略过了">其他方法就先略过了</h3>
<h2 id="0x05-喝口水来个总结">0x05 喝口水，来个总结</h2>
<p>ArrayList 相对来说简单些，但是其中也不乏 contains subList 这种需要注意的方法。知己知彼，方能百战不殆！</p>
<p>文中如有错误，请大家不吝赐教！感激不尽，与君共勉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的HashMap到底是个什么结构]]></title>
        <id>https://lybvinci.github.io/post/chang-yong-de-hashmap-dao-di-shi-ge-shi-me-jie-gou</id>
        <link href="https://lybvinci.github.io/post/chang-yong-de-hashmap-dao-di-shi-ge-shi-me-jie-gou">
        </link>
        <updated>2019-06-02T11:09:38.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="0x00-前言">0x00 前言</h2>
<p>HashMap 是最常用的容器之一，应该没什么疑问了。可你到底了解他吗？网上已经有很多文章来总结 HashMap 了，我来写这篇，主要是为了记录自己阅读之后的一点点小感悟，如若有错误的地方，请大家指正。下文分析基于 <code>jdk1.8</code> 。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="0x00-前言">0x00 前言</h2>
<p>HashMap 是最常用的容器之一，应该没什么疑问了。可你到底了解他吗？网上已经有很多文章来总结 HashMap 了，我来写这篇，主要是为了记录自己阅读之后的一点点小感悟，如若有错误的地方，请大家指正。下文分析基于 <code>jdk1.8</code> 。</p>
<!-- more -->
<h2 id="0x01-一句话介绍">0x01 一句话介绍</h2>
<p>HashMap 内部是一个 Node 类数组，每个节点存放对应的数据。</p>
<h2 id="0x02-概述">0x02 概述</h2>
<p>先来介绍下 HashMap ，主要依据来自 HashMap 的注释（熟悉的同学可以直接跳过到<code>0x03</code>部分）。</p>
<p>1、HashMap 实现了 Map 接口，拥有 Map 的所有操作，具有以下特点：</p>
<ul>
<li>允许 <code>null</code> 的 key 和 value 。</li>
<li>大致上，他和 HashTable 相同，但是 HashTable 是线程安全的，而 HashMap 非线程安全。出于此原因，HashMap 在性能上明显会优于 HashTable 。</li>
<li>不保证顺序，原因在于其内在的原理，他是根据 key 的 hash 值来计算位置的，所以，顺序自然是无法保证的了。（到底怎么算的，往下看。）</li>
</ul>
<p>2、HashMap 的 get , put 在hash值比较均匀的情况下，操作都是常数级别的时间复杂度。一个非常重要的点是，capacity 不能设置太高，load factor 不能设置的太低。（这两个变量又是干嘛的呢，这里先卖个关子✧(≖ ◡ ≖✿)嘿嘿）。</p>
<p>3、因为他不是线程安全的，所以可以通过 Collections.synchronizedMap 来包装，从而变成一个线程安全的 Map。</p>
<p>4、拥有 fail-fast 特性。简单来说，就是在遍历的时候，发现元素被改变，就抛出异常。</p>
<h2 id="0x03-解释几个变量">0x03 解释几个变量</h2>
<h3 id="构造函数里面的-initialcapacity">构造函数里面的 initialCapacity</h3>
<p>这个参数的意思比较明显，就是初始的 Map 长度。默认是 16。</p>
<h2 id="nodekv-table">Node&lt;K,V&gt;[] table</h2>
<p>Map 中真正存放元素的地方，可以看到他是一个 Node 数组。Node 结构比较简单，就是一个 key-value 组成的一个链表，其中还有 hash变量，和 next 变量。</p>
<h3 id="float-loadfactor">float loadFactor</h3>
<p>顾名思义，负载因子。默认值是0.75，是一个空间和时间上的权衡。具体怎么来的，可能是一个复杂的逻辑推算。</p>
<h3 id="int-threshold">int threshold</h3>
<p>阈值，Map 所能容纳的键值对数量。是根据 Map 中的数组长度*loadFactor计算出来的。看到这个，应该就可以想到，如果 loadFactor设置的太小，会有什么问题了。没错，如果设置太小，容量就会很小，导致空间上的一个浪费，大部分的位置都是空的，没有被充分利用。反之，如果设置太大，就会导致元素放置非常拥挤，查询起来效率就会变低。</p>
<h2 id="0x04-方法分析">0x04 方法分析</h2>
<h3 id="构造函数">构造函数</h3>
<p>HashMap 有好几个构造函数，来看一个比较重要的吧。</p>
<pre><code>    public HashMap(int initialCapacity, float loadFactor) {
        // 如果传递进来的初始化数组的大小小于0，就是不合法，直接抛异常。
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        // 如果大于最大的值，就让他等于最大值。
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        // 根据 tableSizeFor 方法进行数组长度的对齐。
        this.threshold = tableSizeFor(initialCapacity);
    }
    
    // 数组长度的对齐。
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        // 经过以下的变化，数组的长度一定是2^n了。 
        n |= n &gt;&gt;&gt; 1;  // 1
        n |= n &gt;&gt;&gt; 2;  // 2
        n |= n &gt;&gt;&gt; 4;  // 3
        n |= n &gt;&gt;&gt; 8;  // 4
        n |= n &gt;&gt;&gt; 16; // 5
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
</code></pre>
<p>在这里给方法<code>tableSizeFor</code>举个🌰：</p>
<pre><code>如果我设置cap为13，则13-1的二进制是：
  0000 0000 0000 1100
此时进行第一步：
          0000 0000 0000 1100
    &gt;&gt;&gt;1  0000 0000 0000 0110
    |=    0000 0000 0000 1110
第二步：
          0000 0000 0000 1110
    &gt;&gt;&gt;2  0000 0000 0000 0011
    |=    0000 0000 0000 1111
第三步：
          0000 0000 0000 1111
    &gt;&gt;&gt;4  0000 0000 0000 0000
    |=    0000 0000 0000 1111
……
可以看出，后面应该全是 1111（2）了。最后加个1，就是16，2^4.
有的同学可能不信，所以再举个更大的🌰：
  0100 0110 0101 0110
此时进行第一步：
          0100 0110 0101 0110
    &gt;&gt;&gt;1  0010 0011 0010 1011
    |=    0110 0111 0111 1111
第二步：
          0110 0111 0111 1111
    &gt;&gt;&gt;2  0001 1001 1101 1111
    |=    0111 1111 1111 1111
第三步：
          0111 1111 1111 1111
    &gt;&gt;&gt;4  0000 0111 1111 1111
    |=    0111 1111 1111 1111
……
可以看到，最终结果还是一样。二进制有很多好玩的特性，如果能利用好，性能上的提升绝对不止一点半点。
</code></pre>
<h3 id="node节点类">Node节点类</h3>
<p>包含一个 hash，key， value。</p>
<h3 id="put">put</h3>
<pre><code>public V put(K key, V value) {
    // 实际调用 putVal 方法。此时可能有个疑问，key他自己不是有hashcode方法吗？为什么还要自己写一个？暂且按下，先看看 putVal 方法。 ①
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    // 如果 tab 还没有被初始化，或者是空，则先进行 resize .
    if ((tab = table) == null || (n = tab.length) == 0)
        // n 就是tab的长度。 ③
        n = (tab = resize()).length;
    // 这里是重点，怎么定位？ (n-1)&amp;hash 来定位的。 ②
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        // 如果是null，则创建一个新的节点。
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&lt;K,V&gt; e; K k;
        // 如果旧节点就是需要被put的节点，则将值直接进行替换。
        // 可以看到他是根据 == 判断是否是同一个对象，或者 equals 方法来判断是否相等。
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        // 如果是 红黑树，则调用红黑树的putTreeVal。
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            // 如果是链表，则一个一个往下寻找，
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    // 如果一直找到结尾，都没找到,则创建一个新节点
                    p.next = newNode(hash, key, value, null);
                    // 如果链表的长度，已经大于了需要转成红黑树的长度，则将其转为红黑树
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                // 找到则终结循环
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        // 如果找到了对应的节点，进行一个替换
        if (e != null) {
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                // 如果标志检查符合，或者原值为null，则进行赋值。
                e.value = value;
            // 节点可用完成通知
            afterNodeAccess(e);
            return oldValue;
        }
    }
    // 修改变更标志加一
    ++modCount;
    // 如果总的节点数量，大于了阈值，则进行扩容
    if (++size &gt; threshold)
        resize();
    // 插入完毕通知
    afterNodeInsertion(evict);
    return null;
}
</code></pre>
<p>讲讲②处，为什么这样定位呢？ (n - 1) &amp; hash 。n 是 table 的长度，是一个 2^n 的数字。一般情况下，如果有一个大于数组长度的位置，我们怎么来将其放入数组中呢？很简单，取模。对这个位置取模，得到的值肯定都是小于数组长度的。划重点！<code>所以这个 (n - 1) &amp; hash 也是取模！我们都知道，n-1 的二进制，都是高位0 + 低位多个1组成的。此时和 hash 值相与，与出来的值，肯定是小于 n-1 的，这就达到了一个取模的效果。</code>空说无凭，还是举个🌰。</p>
<pre><code>假设 n = 16, n-1的二进制即为 1111 。再随便写个32位的hash。
    0000 0000 0000 1111
&amp;   1001 1101 1110 0110
=   0000 0000 0000 0110 = 6 &lt; 16
</code></pre>
<p>方法非常巧妙，避免了取模，大大提升了索引的速度。</p>
<p>此时引出了①的原因。先看看hash的尊容。</p>
<pre><code>// hash 方法。
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<p>来说说这个 hash 方法。可以看到如果是 null，则返回的是0.非null，则调用了key#hashCode方法，并且异或了hash值右移16位。分析②的时候，可以看到定位是根据hash值和n-1相与来确定位置的，这就是为什么要重新一个hash的原因。哈？为什么？根据②的🌰，可以看出来，定位和hash值的前几位都没有关系，只和 n-1 的二进制长度的位数有关。这就带来一个问题，非常容易产生冲突，随机性被降低了，毕竟高xx位都没有参与运算，就那么几位，肯定容易产生冲突。异或这个操作，将高位也拉了进来，大大提高了参与度，hash散列也会更好。还是举一个🌰。</p>
<pre><code>       1110 0010 0011 1101      1110 0000 0011 1101
&gt;&gt;16   0000 0000 1110 0010      0000 0000 1110 0000
^=     1110 0010 1101 1111      1110 0000 1101 1101
可以看到，如果不进行这个操作，这两个元素肯定是在一个定位上的，如果加上高位操作，则被分散了。
</code></pre>
<h3 id="resize">resize</h3>
<p>resize是用来对map进行扩容的方法。对应上面的注释③。</p>
<pre><code>final Node&lt;K,V&gt;[] resize() {
    Node&lt;K,V&gt;[] oldTab = table;
    // 获取旧的数组长度。
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &gt; 0) {
        // 如果已经大于了最大值，就设置阈值最大，直接返回。
        if (oldCap &gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // 阈值翻倍。
    }
    else if (oldThr &gt; 0)
        // 如果阈值大于0&amp;旧的数组长度小于1，则将新数组长度设置为阈值的大小。
        newCap = oldThr;
    else {               // 上述条件都不符合，则使用初始值。。
        newCap = DEFAULT_INITIAL_CAPACITY;
        // 新的阈值是默认负载因子*默认数组长度的值。
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  
    }
    // 如果新阈值为0
    if (newThr == 0) {
        根据是否在范围内，对新阈值赋值，方法同上。
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) { // 如果是扩容，不是初始化，则需要进行元素迁移。
        for (int j = 0; j &lt; oldCap; ++j) {
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) {
                // e 已经引用了就数据，所以将数组对应位置清空，利于垃圾回收。
                oldTab[j] = null;
                if (e.next == null)  // ① 如果链表只有一个元素，则将其放入新数组对应的位置，计算方法已经说过。
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode) //②  如果是一颗红黑树，则利用 split 方法来进行拆树。
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else { // 如果还是链表。 ③
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do {
                        // next 是 e 的下一个元素
                        next = e.next;
                        if ((e.hash &amp; oldCap) == 0) { // e 的 hash 值和旧的数组长度相与为0 ③-1
                            if (loTail == null)  // 如果低位尾部是null，则低位头是 e.
                                loHead = e;
                            else  // 否则，低位尾部接着往下链。
                                loTail.next = e;
                            loTail = e; // 尾指向下一个。
                        }
                        else {  // 否则，对高位尾操作，操作和低位类似。
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    if (loTail != null) { // 将低位链表放置到 j 的位置上。
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) { // 将高位组成的链表放置到 j + oldCap 位置上。
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
</code></pre>
<p>上面一部分都很好理解。重点看看①-③这几个地方。先画个图吧。比如一个 map 的的长度是4，里面如此放置元素（为了举例，假设可以放置这么多）：</p>
<pre><code>[0] -&gt; (0)  //第①种，元素0的后面没有任何元素了，所以直接进行放置
[1] -&gt; (             1               
                5          25
              9   17    21    29
               13                33   ) // 这就属于②了，链表已经被转化为一颗红黑树了。所以需要将树给拆掉。
[2] -&gt; (2 -&gt; 6 -&gt; 10 -&gt; 14) // 这就属于第③种情况了,需要将此链表拆开，放置到新的数组当中。
[3] -&gt; (3)
</code></pre>
<p>在此着重讲讲第三种情况。还是上图。</p>
<pre><code>[0]                                 [0]
[1]                                 [1]
[2]-&gt; (2 -&gt; 6 -&gt; 10 -&gt; 14) -----&gt;   [2] -&gt; (2 -&gt; 10)
[3]                                 [3]
                                    [4]
                                    [5]
                                    [6] -&gt; (6 -&gt; 14)
                                    [7]
                                    [8]
此处看看怎么迁移。先看看他们和旧长度4相与是否为0。
            2       6       10      14 
二进制      0010    0110    1010    1110
&amp;          0100    0100    0100    0100
=          0000    0100    0000    0100
列出4和8的二进制数：
            4       8
二进制      0100    1000
n-1        0011    0111
</code></pre>
<p>可以看出一些规律，长度的二进制总是只有一个1，其余位都是0。而位置计算是 hash&amp;n-1,可以发现，新的位置不过是hash&amp;2n-1，用二进制来看，就是左移了一位补1.所以和原来位置唯一的差别在哪呢，就在这个左移出来的1身上。这就是为什么③-1中为什么判断<code>e.hash &amp; oldCap</code>。如果长度二进制为1的那个位置是0的元素，就留在原地，反之，则放置到 <code>j +oldCap</code> 位置。因为扩容是两倍，所以就是原来的位置加上一个原数组长度。</p>
<h3 id="get">get</h3>
<p>get 方法和 put 方法非常类似。只不过 get 是 get 返回，put 是 set 值进去。内部调用了 getNode 方法。</p>
<h2 id="remove">remove</h2>
<p>remove 和 put 方法也非常类似，就是找到对应的元素，进行删除而已。</p>
<h3 id="containskey">containsKey</h3>
<pre><code>public boolean containsKey(Object key) {
    // 也是调用了get方法调用的内部方法，判断返回的值是否为null。所以和 get 方法只是一个用不用返回值的区别。
    return getNode(hash(key), key) != null;
}
</code></pre>
<h3 id="size">size</h3>
<p>直接返回了记录元素个数的 size 变量。</p>
<h3 id="clear">clear</h3>
<p>遍历数组，挨个进行 null 赋值。</p>
<h3 id="containsvalue">containsValue</h3>
<p>遍历数组和对应的链表，查看 value 是否相等。</p>
<h3 id="红黑树相关的函数">红黑树相关的函数</h3>
<p>这些函数是java8新增的，如果链表过长，一个个遍历非常影响效率，所以 map 内部将他变成了一颗红黑树，此文就不进行详解了。这部分放到 TreeMap 分析的时候再进行描述。</p>
<h2 id="0x05-喝口水来个总结">0x05 喝口水，来个总结</h2>
<p>本文讲解了 HashMap 中的一部分核心问题，没有全部都讲下来。还有resize线程安全问题，红黑树相关的部分没有讲解。线程安全这个，后面也会单独来一篇进行讲解。红黑树则放到 TreeMap 的分析当中。如果文中有误，请大家指出，感激不尽。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[日志SLF4J解惑]]></title>
        <id>https://lybvinci.github.io/post/ri-zhi-slf4j-jie-huo</id>
        <link href="https://lybvinci.github.io/post/ri-zhi-slf4j-jie-huo">
        </link>
        <updated>2019-06-02T11:09:12.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="0x00-前言">0x00 前言</h2>
<p>作为后端开发，日志可能是我们最常用的功能之一了。平时大家也可能经常遇见日志冲突，常见的overflow报错，今天为大家详解一下，这其中的原理以及问题所在。本文涉及 jar 包有：log4j,log4j-over-slf4j,slf4j-api,slf4j-log4j12 等等。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="0x00-前言">0x00 前言</h2>
<p>作为后端开发，日志可能是我们最常用的功能之一了。平时大家也可能经常遇见日志冲突，常见的overflow报错，今天为大家详解一下，这其中的原理以及问题所在。本文涉及 jar 包有：log4j,log4j-over-slf4j,slf4j-api,slf4j-log4j12 等等。</p>
 <!-- more -->
<h2 id="0x01-背景">0x01 背景</h2>
<p>不知道大家在平时开发中，是否经常遇见以下几个问题：</p>
<ul>
<li>log4j,logback等等日志包冲突，然后再慢慢排除，不胜其烦。</li>
<li>使用了 slf4j ，但是又遇到 StackOverflwError 错误。<img src="http://upload-images.jianshu.io/upload_images/1835691-3309d9bb0b52b74d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li>
<li>好不容易解决了StackOverflwError，可能又遇到了类似如图所示的错误：<img src="http://upload-images.jianshu.io/upload_images/1835691-8602b5bf9133fb1e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li>
<li>......</li>
</ul>
<h2 id="0x02-概述">0x02 概述</h2>
<p>什么是 SLF4J 呢？简而言之，他就是一个日志的门面，市场上的日志系统非常多， SLF4J 想做的一件事情，就是将这多种的日志系统包装起来，提供统一的 API 供调用，从而解决日志的列国争霸的情况。</p>
<h2 id="0x03-slf4j-调用流程">0x03 SLF4J 调用流程</h2>
<p>在解决以上问题之前，让我们先对日志系统做一个大概的理解。到底什么是 log4j,什么是 slf4j-api,为什么有一个 slf4j-log4j12,又怎么有个log4j-over-slf4j，看上去头晕眼花，绕来绕去。先祭上一张官网图：<img src="http://upload-images.jianshu.io/upload_images/1835691-7cf6c84f16beb3e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">
相信大家都见过这张图，但是未必全都理解图上说的是什么意思。所以呢，我们先不讲图，先看看最上面的一排文字，SLF4J bound to xxxx,xxxx总共涉及：</p>
<ol>
<li>null</li>
<li>logback-classic</li>
<li>log4j</li>
<li>java.util.logging</li>
<li>simple</li>
<li>no-operation</li>
</ol>
<p>第1个顾名思义，不绑定，就是没有日志实现。第5，6可以看出来，是 SLF4J 自己的实现，这里就忽略不讲。所以着重讲一下2、3、4。他们有个共同的特点，就是他们都是日志的真正实现库，他们和SLF4J没有关系，你可以使用 logback 打印日志，也可以使用 log4j 打日志。</p>
<p>第一层， application 就是应用层。</p>
<p>看看图中第二层，统统都是 SLF4J API。那么这一层是干什么用的呢？这一层就是一个门面层，而和门面层息息相关的 jar 包是什么呢？对，就是图中的 slf4j-api.jar 。这个jar包中，提供了日志调用的所有接口，应用都是直接调用这个 jar 包中的接口进行日志调用。</p>
<p>第三层有点不同。第一列，无实现，第2，5，6都是原生的一个实现，而3，4都有一个适配层。这里说说 logback。logback 他为什么不需要适配层呢，因为他就是按照了 SLF4J 接口去实现的一个日志库，相当于亲儿子，自然不需要适配层。所以，logback-classic.jar 和 logback-core.jar 就是 logback  的底层实现。而3，4就不同了，他们的接口或多或少会有差异，调用方式也各不相同，所以，需要一个适配层。所以 slf4j-log412.jar 和 slf4j-jdk14.jar 包的作用就是一个适配，这里是一个桥接，应用通过 slf4j-api 的接口调用过来时，桥接类实际会调用其底层的实现，达到一个桥接的过程。所以，slf4j-log412.jar,slf4j-jdk14.jar,slf4j-simple.jar,slf4j-nop.jar 是同一类，就是把<code>-</code>右边的实现进行一个桥接。</p>
<p>第四层，可以看到第2，3对应的实现，log4j.jar 和 jvm 就是最后的实现。</p>
<p>至此，做一个小总结：</p>
<ol>
<li>slf4j-api.jar 是上层的门面，里面提供接口供调用。</li>
<li>logback-classic.jar, logback-core.jar, log4j.jar, 是同一类别，属于底层实现库。</li>
<li>slf4j-log412.jar,slf4j-jdk14.jar,slf4j-simple.jar,slf4j-nop.jar，可以看成 slf4j-xxxx.jar,属于同一个类别，就是对 - 后面的库做一个桥接，更简单的理解，从左到右读：把 - 左边的调用用右边的库实现。</li>
</ol>
<p>此时再看看上面那张图，是否已经全部理解了呢？</p>
<h2 id="0x04-slf4j-转换流程">0x04 SLF4J 转换流程</h2>
<p>如果看完上面，不觉得 SLF4J 有什么好处，就来看看下面这张图：<img src="http://upload-images.jianshu.io/upload_images/1835691-4b9913272e3e6e1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">
那这张图又是什么意思呢？这就要说到 SLF4J 的一个强大之处了。设想一下以下一种情况：新建了一个工程，引入的第一个库使用的是 java.util.logging 日志库，引入的第二个库使用的是 log4j 日志库，而你自己的工程，老板规定，必须要用 logback 。你怎么办呢？这个时候， SLF4J 就出场了。他能帮你把所有日志归拢到你所指定的一种日志实现。就是说，他可以把 jul 日志实现转成 logback，还能把 log4j 实现转成 logback。那他是怎么做的呢？回过头来看图吧。</p>
<p>着重讲解左上角这一部分，其他的类似。</p>
<p>先看 application，这个是应用，可以看到，他也遇到了我说到的问题。他的依赖里面有使用 log4j 的，有用 commons logging 的，有用 java.util.logging 的。所以此时需要做一个替换，分别是通过 jcl-over-slf4j.jar 替换掉 commons-logging.jar,log4j-over-slf4j.jar 替换掉 log4j.jar, jul-to-slf4j.jar 包中安装 SLF4JBrindgeHandler 解决。替换掉之后，就把所有日志调用转接到 slf4j-api 上了，然后 api 接口再调用底层实现，图上是 logback。文中说的替换是什么意思呢？就是把原日志实现库排除掉，引入 xxx-over-slf4j.jar 。</p>
<p>那么，xxx-over-slf4j.jar 是什么原理呢？先给大家看这张图：
<img src="http://upload-images.jianshu.io/upload_images/1835691-f9f2b07f33d96b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">
左边是 log4j.jar 的包结构，右边是 log4j-over-slf4j.jar 的包结构。发现猫腻了吗？他们的目录结构一模一样！所以用 log4j-over-slf4j 可以替换掉 log4j！且编译不会出错。log4j-over-slf4j.jar 实现了基本上所有 log4j 会被调用的 api 接口。所以替换之后，不会报错，编译也能通过，而底层实现却全转到 slf4j 这里去了。这里就是一个狸猫换太子的把戏。</p>
<p>再看其他两个图，底层分别是 log4j, jvm 实现。都是讲其他库 over 一下到 slf4j 。</p>
<p>特别注意一下， logback 不需要转，为什么？因为他是亲儿子。天生就带这些。</p>
<p>所以再小总结一下：</p>
<ul>
<li>jcl-over-slf4j.jar, log4j-over-slf4j.jar, jul-to-slf4j.jar，这种形式类似 xxx-over-slf4j.jar 的，就是将 <code>-</code> 前的太子用 slf4j 的狸猫代替。而 xxx-to-slf4j.jar 比较特殊，这是因为 xxx 这个包无法被替换掉，比如 java.util.logging,系统的库，无法替换，所以只能采用别的手段。此类别的实现读者有兴趣可以去看看，本文不再分析。</li>
</ul>
<h2 id="0x05-常见问题解决">0x05 常见问题解决</h2>
<h3 id="stackoverflow-错误">StackOverflow 错误</h3>
<p>为什么会出现这个问题呢？控制台输出上一般会比较清楚，就是你既使用了桥接库，又使用了over库（狸猫）。比如：<img src="http://upload-images.jianshu.io/upload_images/1835691-aadcaa4058d11782.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">
试想一下：你先用 over 库把 log4j 转成了 slfj4 调用。紧接着，你又把 slf4j 适配到 log4j 上。这就构成了一个死循环，肯定是会出现堆栈溢出的问题。所以，一个工程里面，只能保留一个日志实现库，还有配套的桥接库，加上其他日志的 over 库，才是正确之道。</p>
<h3 id="异常参数错误">异常参数错误</h3>
<p>上面提到的这个错误：
<img src="http://upload-images.jianshu.io/upload_images/1835691-c88f10cccc03f135.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">
大致可以看出来吧，他缺少一个真正的实现。看你选择使用什么，就把什么库补充上去。加上 logback，去掉 slf4j-log4j 或者加上 log4j 都可以解决这个问题。</p>
<p>其他问题都比较类似，如果看懂了上文的介绍，应该可以着手解决此类问题了。</p>
<h2 id="0x06-不算总结的总结">0x06 不算总结的总结</h2>
<p>了解了日志的原理，以后妈妈再也不担心日志冲突了！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[intellij创建springboot项目]]></title>
        <id>https://lybvinci.github.io/post/intellij-chuang-jian-springboot-xiang-mu</id>
        <link href="https://lybvinci.github.io/post/intellij-chuang-jian-springboot-xiang-mu">
        </link>
        <updated>2019-06-02T11:08:08.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="如何利用intelij创建springboot项目">如何利用intelij创建springboot项目</h2>
<p>选择file - new - project</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="如何利用intelij创建springboot项目">如何利用intelij创建springboot项目</h2>
<p>选择file - new - project</p>
<!-- more -->
<p><img src="http://upload-images.jianshu.io/upload_images/1835691-35ce96ebf3b4c5f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">
点击下一步。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1835691-60935bc2266b3f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">
设置完包名，接下来就是按照自己的需要，一路下一步就ok了。</p>
<h2 id="so-就是这么简单-可能一开始找不到选择哪个的比较多再次记录一下">so 就是这么简单。可能一开始找不到选择哪个的比较多，再次记录一下。</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nodejs 启动流程分析（1）]]></title>
        <id>https://lybvinci.github.io/post/nodejs-qi-dong-liu-cheng-fen-xi-1</id>
        <link href="https://lybvinci.github.io/post/nodejs-qi-dong-liu-cheng-fen-xi-1">
        </link>
        <updated>2019-06-02T11:07:43.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>之前用过一段时间的<code>v8</code> ，也只是会初始化那个流程，最近想深入了解一下，所以想要通过学习 <code>nodejs</code> 来加深理解。这篇文章主要是讲讲 <code>nodejs</code> 的初始化流程，如有错误，烦请指教~。（本文分析基于 v10.9.0，本文会尽量避免大段源码，但是为了有理有据，还是会放上一些精简过并带有注释的代码上来）。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>之前用过一段时间的<code>v8</code> ，也只是会初始化那个流程，最近想深入了解一下，所以想要通过学习 <code>nodejs</code> 来加深理解。这篇文章主要是讲讲 <code>nodejs</code> 的初始化流程，如有错误，烦请指教~。（本文分析基于 v10.9.0，本文会尽量避免大段源码，但是为了有理有据，还是会放上一些精简过并带有注释的代码上来）。</p>
<!-- more -->
<p>Helloworld 镇楼：</p>
<pre><code class="language-js">const http = require('http');
const hostname = '127.0.0.1';
const port = 8888;

http.createServer((req, res) =&gt; {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('Hello World\n');
}).listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
</code></pre>
<p>写过 nodejs 的都能看懂如上代码。寥寥数行，就创建了一个 http 服务。第一行代码，就出现了一个 require 关键字，那么 require 是从何而来呢？带着这个问题，我们一起去看下吧。</p>
<h2 id="启动流程">启动流程</h2>
<p><strong>1.</strong> node 的目录结构，此处就不再分析了。最重要的就是 src 和 lib 了。 src 路径下是 node 的 C++ 实现的主要源码目录，而 lib 主要是 JavaScript 实现所在目录。稍微有一些 C++ 编程基础的同学应该知道，C++ 的启动函数就是 main 函数。那么 node 的启动函数在哪呢。通过全文搜索，可以确定，启动函数就在 <a href="https://github.com/nodejs/node/blob/master/src/node_main.cc">src/node_main.cc</a> 这个文件当中了。此处截取部分源码：</p>
<pre><code class="language-c++">// windows 启动方法。
int wmain(int argc, wchar_t* wargv[]) {
  //...
  // 启动方法。
  return node::Start(argc, argv);
}
//...
// 类linux 启动方法。
int main(int argc, char* argv[]) {
    // ...
    // 启动方法。
    return node::Start(argc, argv);
}
</code></pre>
<p>可以看到，这个只是一个外壳，做了一些逻辑判断，最终的核心就是调用 Start 方法。</p>
<p><strong>2.</strong> Start 方法位于 <a href="https://github.com/nodejs/node/blob/master/src/node.cc">src/node.cc</a>:</p>
<pre><code class="language-C++">int Start(int argc, char** argv) {
    //...
    Init(&amp;argc, const_cast&lt;const char**&gt;(argv), &amp;exec_argc, &amp;exec_argv); // 1.
    // v8 初始化。
    InitializeV8Platform(per_process_opts-&gt;v8_thread_pool_size);
    v8_initialized = true;
    // 开始事件循环。
    const int exit_code =
        Start(uv_default_loop(), args, exec_args);  // 2.
    //... v8 开始销毁。
    v8_initialized = false;
    V8::Dispose();
	//...
    return exit_code;
}
</code></pre>
<p>可以看到，Start 方法主要是执行了一个 Init 方法以及对 v8 进行了初始化的操作，然后开启了整个事件循环流程。</p>
<p><strong>2.1</strong> 来看看 Init 方法做了些什么事情，同样位于 <a href="https://github.com/nodejs/node/blob/master/src/node.cc">src/node.cc</a> 中：</p>
<pre><code class="language-C++">void Init(int* argc,
          const char** argv,
          int* exec_argc,
          const char*** exec_argv) {
  //... 注册内部模块。 此处暂时不细讲。
  RegisterBuiltinModules();
  //...  处理参数，打印 help 等。
  ProcessArgv(argv, exec_argv, false);
  //...
}
</code></pre>
<p><strong>2.2</strong> 接着让我们看看里面这个 Start 方法做了什么。同样位于 <a href="https://github.com/nodejs/node/blob/master/src/node.cc">src/node.cc</a> 中：</p>
<pre><code class="language-c++">inline int Start(uv_loop_t* event_loop,
                 const std::vector&lt;std::string&gt;&amp; args,
                 const std::vector&lt;std::string&gt;&amp; exec_args) {
  //... 开始创建 Isolate 实例。 
  Isolate* const isolate = NewIsolate(allocator.get(), event_loop);
  //...
  {
    //... 又是一个 Start 。
    exit_code = Start(isolate, isolate_data.get(), args, exec_args);
  }
  // isolate 销毁。
  isolate-&gt;Dispose();
  //...
  return exit_code;
}
</code></pre>
<p>参数检查什么的就略过了，上来先创建了一个 Isolate 实例，这个实例相当于是一个 js 独立环境，更粗略一点，比作一个页面。 中间又调用了一个 Start 方法，最终处理一下 isolate 的销毁。</p>
<p><strong>3.</strong> 那接着来看这个 Start 方法（麻木了，都叫 Start 方法。）同样位于 <a href="https://github.com/nodejs/node/blob/master/src/node.cc">src/node.cc</a> 中：</p>
<pre><code class="language-c++">inline int Start(Isolate* isolate, IsolateData* isolate_data,
                 const std::vector&lt;std::string&gt;&amp; args,
                 const std::vector&lt;std::string&gt;&amp; exec_args) {
  //... 创建一个 Context
  Local&lt;Context&gt; context = NewContext(isolate); // 1.
  //... 创建一个 Environment 实例，并开启 Start 方法。
  Environment env(isolate_data, context, v8_platform.GetTracingAgentWriter());
  env.Start(args, exec_args, v8_is_profiling); // 2.
  {
    //... 环境加载
    LoadEnvironment(&amp;env);  // 3.
    //...
  }

  {
    //...
    do {
      // 事件循环启动。libuv 相关。 4.
      uv_run(env.event_loop(), UV_RUN_DEFAULT);
      //...
    } while (more == true);
    //...
  }
  //...
  const int exit_code = EmitExit(&amp;env);
  //... 善后工作，资源回收等等。
  return exit_code;
}
</code></pre>
<p>Context 又是 v8 的一个概念，相当于执行上下文，js 的执行上下文，可以实现互不影响。比如一个页面上嵌套了某个页面，那么他们之间的 js 上下文环境就不一样。此处需要关注 1 , 2，3，4 四个方法。</p>
<p><strong>3.1</strong> 先来看看 1 ,如何创建的 Context。NewContext 同样位于 <a href="https://github.com/nodejs/node/blob/master/src/node.cc">src/node.cc</a> 中：</p>
<pre><code class="language-C++">Local&lt;Context&gt; NewContext(Isolate* isolate,
                          Local&lt;ObjectTemplate&gt; object_template) {
  // 使用 v8 的 api 创建 Context。 
  auto context = Context::New(isolate, nullptr, object_template);
  // ...
  {
    // ... Run lib/internal/per_context.js
    // 获取 per_context.js 文件的字符串。
    Local&lt;String&gt; per_context = NodePerContextSource(isolate);
    // 编译运行，v8的模板代码。
    ScriptCompiler::Source per_context_src(per_context, nullptr);
    Local&lt;Script&gt; s = ScriptCompiler::Compile(
        context,
        &amp;per_context_src).ToLocalChecked();
    s-&gt;Run(context).ToLocalChecked();
  }
  return context;
}

</code></pre>
<p>此方法不仅仅创建了一个 Context，而且还预加载执行了一段js。注意这个 NodePerContextSource 方法只有编译过才会有这个文件。</p>
<p><strong>3.1.1</strong> 看一下这个方法.文件位于<a href="files://younode-path/out/Release/obj/gen/node_javascript.cc">node_javascript.cc</a> 中：</p>
<pre><code class="language-C++">v8::Local&lt;v8::String&gt; NodePerContextSource(v8::Isolate* isolate) {
    return internal_per_context_value.ToStringChecked(isolate);
}
static const uint8_t raw_internal_per_context_value[] = { 39,...}
static struct : public v8::String::ExternalOneByteStringResource {
    const char* data() const override {
        return reinterpret_cast&lt;const char*&gt;(raw_internal_per_context_value);
    }
    //...
    v8::Local&lt;v8::String&gt; ToStringChecked(v8::Isolate* isolate) {
        return v8::String::NewExternalOneByte(isolate, this).ToLocalChecked();
    }
} internal_per_context_value;
</code></pre>
<p>看到这里应该知道了，就是把 raw_internal_per_context_value 这个数组转成 v8 的字符串返回出去。那么问题来了，这个数组里面到底是什么东西呢。</p>
<p><strong>3.1.2</strong> 猜也没法猜，那就打印一下呗。打印数组相关代码如下：</p>
<pre><code class="language-C++">#include &lt;string&gt;
#include &lt;iostream&gt;
static const unsigned char raw_internal_per_context_value[] = {39,...}
int main() {
    std::cout &lt;&lt; (char *)raw_internal_bootstrap_loaders_value &lt;&lt; std::endl;
}
</code></pre>
<p>g++ -o test test.cc &amp; ./test 就可以看到内容了。你会惊奇的发现，这不就是 lib/internal/per_context.js 文件的内容吗？是的，的确是这样，他就是把这段文本直接在编译期间就编成C++字符数组，为了在启动的时候加快启动速度，不至于现场去读文件从而引发文件加载速度的等等一系列问题。至于此 js 文件内容，在此先不做讲解。接着让我回到 4~5步的方法2当中。</p>
<p>**3.2 ** env.Start 方法位于 <a href="https://github.com/nodejs/node/blob/master/src/env.cc">src/env.cc</a> 中：</p>
<pre><code class="language-C++">void Environment::Start(const std::vector&lt;std::string&gt;&amp; args,
                        const std::vector&lt;std::string&gt;&amp; exec_args,
                        bool start_profiler_idle_notifier) {
    //... 一大堆的 uv 操作等等。
    // 设置了 process。
    auto process_template = FunctionTemplate::New(isolate()); 
    process_template-&gt;SetClassName(FIXED_ONE_BYTE_STRING(isolate(), &quot;process&quot;));
    // ...
}
</code></pre>
<p>可以看到其中设置了 process 是什么，此处设置了之后，在js里面就可以直接拿到 process 变量了。</p>
<p><strong>3.3</strong> LoadEnvironment 方法在 <a href="https://github.com/nodejs/node/blob/master/src/node.cc">src/node.cc</a> 中：</p>
<pre><code class="language-C++">void LoadEnvironment(Environment* env) {
  //...
  // 加载 lib/internal/bootstrap/loaders.js 和 node.js 进来。
  // FIXED_ONE_BYTE_STRING 就是一个转换字符串的宏。
  Local&lt;String&gt; loaders_name =
      FIXED_ONE_BYTE_STRING(env-&gt;isolate(), &quot;internal/bootstrap/loaders.js&quot;);
  // LoadersBootstrapperSource 是获取 loaders.js 的文件内容。 GetBootstrapper 方法是用来
  // 执行 js 的。
  MaybeLocal&lt;Function&gt; loaders_bootstrapper =
      GetBootstrapper(env, LoadersBootstrapperSource(env), loaders_name);
  //...
  // 获取 global 对象
  Local&lt;Object&gt; global = env-&gt;context()-&gt;Global();
  //...
  // 暴露 global 出去，在 js 中可以访问。
  global-&gt;Set(FIXED_ONE_BYTE_STRING(env-&gt;isolate(), &quot;global&quot;), global);

  // 创建bind,linked_binding,internal_binding
  Local&lt;Function&gt; get_binding_fn =
      env-&gt;NewFunctionTemplate(GetBinding)-&gt;GetFunction(env-&gt;context())
          .ToLocalChecked();
  //...

  // 执行 internal/loaders.js,node.js 里面的方法。
  if (!ExecuteBootstrapper(env, loaders_bootstrapper.ToLocalChecked(),
                           arraysize(loaders_bootstrapper_args),
                           loaders_bootstrapper_args,
                           &amp;bootstrapped_loaders)) {
    return;
  }
  //...
}

static void GetBinding(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  // ... 通过参数获取模块名。
  Local&lt;String&gt; module = args[0].As&lt;String&gt;();
  //... 获取内部模块。此处就是通过2.1步骤中的 RegisterBuiltinModules 宏处理之后的东西来获取的。
  node_module* mod = get_builtin_module(*module_v);
  Local&lt;Object&gt; exports;
  if (mod != nullptr) {
    // 调用模块初始化方法。
    exports = InitModule(env, mod, module);
  }
  // ... 设置返回值。
  args.GetReturnValue().Set(exports);
}
</code></pre>
<p>代码很长，但是条理还是挺清晰的。这里进行了一些绑定操作和一些初始化方法的调用逻辑。此处也可以知道，GetBinding 类似的东西是什么。调用的 js 如何执行需要和 js 一起看才能明白。此处先不讲解了。</p>
<p><strong>3.4</strong> uv_run 这个方法此处也不细讲了。 libuv 这个库还没有详细了解。等待了解之后，补上 libuv 的相关调用分析，此处我们知道，在这里开始执行事件循环了。</p>
<h2 id="结语">结语</h2>
<p>讲了这么多，大家应该对 nodejs 的启动流程有了一个大致的了解了吧。虽然开头说少点源码，可是后来还是夹杂了很多的源码，哈哈，有一种上当的感觉。后面再讲讲模块加载，libuv加载的相关东西。这次分析就到此结束吧，大家休息~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nodejs 启动流程分析（2）]]></title>
        <id>https://lybvinci.github.io/post/nodejs-qi-dong-liu-cheng-fen-xi-2</id>
        <link href="https://lybvinci.github.io/post/nodejs-qi-dong-liu-cheng-fen-xi-2">
        </link>
        <updated>2019-06-02T11:07:19.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>上篇 <a href="https://www.jianshu.com/p/c02fec0defcf">nodejs 启动流程分析</a>中，遗留了几个问题。这一篇，主要讲讲模块加载流程。大家都应该熟悉 timer 模块的相关功能。我们就以 timer 为引子，一步步看下去吧。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>上篇 <a href="https://www.jianshu.com/p/c02fec0defcf">nodejs 启动流程分析</a>中，遗留了几个问题。这一篇，主要讲讲模块加载流程。大家都应该熟悉 timer 模块的相关功能。我们就以 timer 为引子，一步步看下去吧。</p>
 <!-- more --> 
<h2 id="c-init-方法开始">C++ init 方法开始</h2>
<p>下列函数都在 <a href="https://github.com/nodejs/node/blob/master/src/node.cc">src/node.cc</a> 中：</p>
<pre><code class="language-c++">void Init(std::vector&lt;std::string&gt;* argv,
          std::vector&lt;std::string&gt;* exec_argv) {
  ...
  // 注册内部模块。
  RegisterBuiltinModules();
  ...
}
</code></pre>
<p>乍一看，这个 RegisterBuiltinModules 方法应该就是关键所在了。那看看他是什么吧。</p>
<pre><code class="language-C++">void RegisterBuiltinModules() {
#define V(modname) _register_##modname();
  NODE_BUILTIN_MODULES(V)
#undef V
}
</code></pre>
<p>原来不是方法，而是一个宏定义。那我们再看看 NODE_BUILTIN_MODULES 这个是什么吧。下列文件位于<a href="https://github.com/nodejs/node/blob/master/src/node_internals.h">src/node_internals.h</a> 中：</p>
<pre><code class="language-C++">#define NODE_BUILTIN_MODULES(V)                                               \
  NODE_BUILTIN_STANDARD_MODULES(V)                                            \
  NODE_BUILTIN_OPENSSL_MODULES(V)                                             \
  NODE_BUILTIN_ICU_MODULES(V)
</code></pre>
<p>乖乖，又是一个宏。简直就是宏的地狱。让我们耐着性子，再往下看看。</p>
<pre><code>#define NODE_BUILTIN_STANDARD_MODULES(V)                                      \
    V(async_wrap)                                                             \
    ...
    V(timer)                                                                 \
</code></pre>
<p>其他两个宏类似，就不放上来了。在这个宏里面，貌似看到了想要查找的 timer 。那我们把这个三个宏合成一下，看看是什么吧。</p>
<pre><code class="language-C++">_register_timer();
</code></pre>
<p>其他类似，不再赘述。原来这个宏就是依次调用了 _register_xx 方法。插一句，在 C++ 宏里面，## 代表字符串连接。相当于用 ## 之前的字符串 拼接上 ## 之后的字符串。现在看来，找到这个 _register_timer() 方法就是关键了。全文搜索一下 _register_timer() 方法，发现无法找到。再尝试搜索一下 <em>register</em>  这个关键字，可以找到一个宏如下，在文件<a href="https://github.com/nodejs/node/blob/master/src/node_internals.h">src/node_internals.h</a>中：</p>
<pre><code class="language-C++">#define NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags)          \
  static node::node_module _module = {                                        \
    NODE_MODULE_VERSION,   /*版本号*/                                          \
    flags,                 /*模块类型，builtin,internal,linked*/                \
    nullptr,               /*nm_dso_handle. 未知*/                             \
    __FILE__,              /*文件名*/                                          \
    nullptr,               /*注册方法*/                                         \
    (node::addon_context_register_func) (regfunc),    /*注册上下文*/            \
    NODE_STRINGIFY(modname),          /*模块名*/                               \
    priv,                             /*私有*/                                 \
    nullptr                           /*下一个 node_module 模块节点*/            \
  };                                                                          \
  void _register_ ## modname() {                                              \
    node_module_register(&amp;_module);                                           \
  }
</code></pre>
<p>可以看到，这个宏定义了一个结构体，node_module 是在 <a href="https://github.com/nodejs/node/blob/master/src/node.h">src/node.h</a>里面定义的。这个宏把模块名，注册方法，私有指针，模块类型传递进来了。然后还定义了一个方法，就是我们要找的 _register_##modname方法。其中又调用了 mode_module_register 方法。此处我们先不着急看实现，而是先去看看是谁调用了这个宏。搜索下来发现，在文件<a href="https://github.com/nodejs/node/blob/master/src/node_internals.h">src/node_internals.h</a>中有这样一个宏：</p>
<pre><code class="language-C++">#define NODE_MODULE_CONTEXT_AWARE_INTERNAL(modname, regfunc)                  \
  NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, nullptr, NM_F_INTERNAL)
</code></pre>
<p>NODE_MODULE_CONTEXT_AWARE_INTERNAL 这个宏调用了上面的宏，并且将模块名，注册方法传递进来，私有变量传null，模块类型传内置模块类型。接着再看看谁调用了NODE_MODULE_CONTEXT_AWARE_INTERNAL。搜索可以看到很多处调用，我们找到我们关心的 <a href="https://github.com/nodejs/node/blob/master/src/timers.cc">src/timers.cc</a>文件查看：</p>
<pre><code class="language-C++">void Initialize(Local&lt;Object&gt; target,
                       Local&lt;Value&gt; unused,
                       Local&lt;Context&gt; context) {
  ...
  env-&gt;SetMethod(target, &quot;getLibuvNow&quot;, GetLibuvNow);
  ...
  target-&gt;Set(env-&gt;context(),
              FIXED_ONE_BYTE_STRING(env-&gt;isolate(), &quot;immediateInfo&quot;),
              env-&gt;immediate_info()-&gt;fields().GetJSArray()).FromJust();
}
NODE_MODULE_CONTEXT_AWARE_INTERNAL(timers, node::Initialize)
</code></pre>
<p>可以看到，模块名参数就是 timers, 初始化方法参数传递的是 Initialize 方法。到这，算是找到调用根源了。那我们接着看看 node_module_register 方法干了些什么。此方法在 <a href="https://github.com/nodejs/node/blob/master/src/node.cc">src/node.cc</a>中：</p>
<pre><code class="language-C++">extern &quot;C&quot; void node_module_register(void* m) {
  struct node_module* mp = reinterpret_cast&lt;struct node_module*&gt;(m);
  ...
  else if (mp-&gt;nm_flags &amp; NM_F_INTERNAL) {
    mp-&gt;nm_link = modlist_internal;
    modlist_internal = mp;
  }
  ...
}
</code></pre>
<p>你会惊奇的发现，这里仅仅是把所有的模块依次链接起来，形成一个链表。没有调用呀？没有初始化啊？此处注意一下变量<strong>modlist_internal</strong>,后面会用到。这里有一个 GetInternalBinding 。他被绑定到 global 对象上，会被 js 调用。此方法是必须结合js源码才能明白出处。此方法在<a href="https://github.com/nodejs/node/blob/master/src/node.cc">src/node.cc</a>中：</p>
<pre><code class="language-C++">static void GetInternalBinding(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
  ...//获取参数名。
  Local&lt;String&gt; module = args[0].As&lt;String&gt;();
  ...//获取内部模块。
  node_module* mod = get_internal_module(*module_v);
  if (mod != nullptr) {
      // 初始化。
    exports = InitModule(env, mod, module);
  }
  ...
}
</code></pre>
<p>让我们看看 get_builtin_module 方法，此方法在<a href="https://github.com/nodejs/node/blob/master/src/node.cc">src/node.cc</a>中：</p>
<pre><code class="language-C++">node_module* get_internal_module(const char* name) {
  return FindModule(modlist_internal, name, NM_F_INTERNAL);
}

inline struct node_module* FindModule(struct node_module* list,
                                      const char* name,
                                      int flag) {
  struct node_module* mp;
  for (mp = list; mp != nullptr; mp = mp-&gt;nm_link) {
    if (strcmp(mp-&gt;nm_modname, name) == 0)
      break;
  }
  ...
  return mp;
}
</code></pre>
<p>方法内部调用了 FindModule 方法。第一个参数熟悉吗?**modlist_internal!**就是通过上面的 RegisterBuiltinModules 方法来生成的模块。具体的查找过程也比较简单，就是遍历这个链表，一个个比较模块名，是否相同，然后拿到模块。再继续看一下 InitModule 方法，同样位于<a href="https://github.com/nodejs/node/blob/master/src/node.cc">src/node.cc</a>：</p>
<pre><code class="language-C++">static Local&lt;Object&gt; InitModule(Environment* env,
                                 node_module* mod,
                                 Local&lt;String&gt; module) {
  ...//直接调用node_module模块的注册上下文的方法，并传入对应的一些参数。
  mod-&gt;nm_context_register_func(exports,
                                unused,
                                env-&gt;context(),
                                mod-&gt;nm_priv);
  return exports;
}
</code></pre>
<p>回想下上面的 timer.cc 中的 Initialize 方法，此处就是调用的地点了。至此，模块就加载到程序当中了。</p>
<h2 id="尾言">尾言</h2>
<p>分析过程中，会遇到很多的宏处理，此时可以将宏一个个展开，然后写到纸上进行分析。否则一眼很难看的清全貌。</p>
<p>通过本文，应该对 RegisterModules，和如何初始化模块应该有了一个大致的了解。但是你可能还是会有一些迷惑，比如 GetInternalBinding 这个方法谁调用的呢，下次来进行分析~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web容器项目总结]]></title>
        <id>https://lybvinci.github.io/post/web-rong-qi-xiang-mu-zong-jie</id>
        <link href="https://lybvinci.github.io/post/web-rong-qi-xiang-mu-zong-jie">
        </link>
        <updated>2019-06-02T11:06:54.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>蘑菇街是一个专门为女性购物打造的时尚购物平台，App端承接了大量的流量，及时发布新内容成为一个挑战。在保证平台稳定性和迅速更新的前提下，我们选择了native和h5的混合开发，并对其不断的进行了优化迭代。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>蘑菇街是一个专门为女性购物打造的时尚购物平台，App端承接了大量的流量，及时发布新内容成为一个挑战。在保证平台稳定性和迅速更新的前提下，我们选择了native和h5的混合开发，并对其不断的进行了优化迭代。</p>
 <!-- more -->
<h2 id="方案">方案</h2>
<h3 id="内核选择">内核选择</h3>
<ul>
<li>由于安卓碎片化严重，webview 性能不一，初期我们选择编译打包 crosswalk 项目提供的容器内核进行动态加载，在 app 空闲的时候，下载此内核，并在下载完成后，动态加载到系统中。在 web 容器启动的时候判断相应的版本号以及文件完整性，选择性的加载两种内核。数据表明，在安卓4.4及以下机型上，crosswalk 的性能有很大的优势。</li>
<li>在这个环节，比较重要的是要提高内核下载的到达率，解决用户网络连接断开，或者应用被杀死，进程中断，文件完整性的问题。我们做了大量工作，通过判断网络情况，文件下载结果的验证，防止出现下载死循环，导致用户手机内存爆炸的问题。最终到达率在95%以上。</li>
</ul>
<h3 id="能力扩展">能力扩展</h3>
<ul>
<li>web 天生就有动态的特性，但在 native 端也有其不足的地方。就是他的权限不足，无法访问 native 的一些系统功能，比如添加日历，访问通讯录等。这些在电商应用中都是常见的需求。由于这个问题，我们提供了统一的内核访问 api ，然后接入 Cordova 。Cordova是一个能让 JavaScript 访问原生设备功能，如摄像头、麦克风等的库。</li>
<li>Cordova原理探究：通过继承<code>WebChromeClient</code>类，复写 <code>onJsPrompt</code> 方法,在其中通过<code>CordovaBridge</code>类，桥接到自己的功能点，通过自己定义好的协议，实现对应的功能。Cordova的一个强大的地方，就是他有插件机制，业务方可以很容易的扩展插件，js调用native回非常方便，只要继承一下<code>CordovaPlugin</code>类，在<code>execute</code>方法中执行自己的逻辑即可。</li>
<li>结合难点
<ul>
<li>由于我们封装了自己的内核，而且是采用自己定制的一套接口，就不能直接使用Cordova官方仓库提供的已经封装好的 <code>SystemWebview</code> 类，所以需要深入了解他的一些逻辑，才能进行调用，否则会遇到深坑。</li>
<li>调试需要结合js一起进行，在前端有一个 deviceready 事件会传递到native端，如果调用时机错误，Cordova 就会加载失败，从而导致传递给桥接类的秘钥错误，调用直接失败。</li>
<li>我们自己的内核封装不完善，有一些方法实现不一致，有些方法没有。此时需要去看源码类似的地方，进行调用尝试。</li>
</ul>
</li>
</ul>
<h3 id="数据分析">数据分析</h3>
<p>既然使用了多种内核，就要对不同的内核进行数据分析。在客户端进行对应的性能打点，在数据平台上通过 sql 语句进行数据清洗，并每天定时生成。利用 Reactjs 开发了数据展示的前端界面，每天可以查看昨日的内核分布，机型占比，性能对比等数据，为内核的性能保证提供数据支撑。</p>
<h2 id="问题">问题</h2>
<ul>
<li>兼容性问题。经常会有前端同学来问在某些机型上面是好的，在另外一个机器上就不行。此类问题通常是因为各个设备不兼容导致的，各大应用厂商都会对系统进行一些定制，导致问题百出。由于各个版本的 webview 存在兼容性问题，后来我们又接入了腾讯的 x5 内核。</li>
<li>安卓系统不断的更新演进，旧的内核越来越少，webview 性能都显著提高，我们自己的内核面临下架的问题。最终在2016年12月，将 crosswalk 的内核下载停掉。</li>
<li>crosswalk 另一个问题是存在硬件加速问题，他使用的是 surfaceview ，在低端机型上，很容易内存不够，被系统杀掉。</li>
</ul>
<h2 id="总结">总结</h2>
<p>整个项目包含的内容不只文字所能术完，在此期间，同事们和我都做了很多努力，在保证功能的前提下，不断的做优化，提升性能，最终将蘑菇街的页面加载速度提升到秒级。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XCore开发体验]]></title>
        <id>https://lybvinci.github.io/post/xcore-kai-fa-ti-yan</id>
        <link href="https://lybvinci.github.io/post/xcore-kai-fa-ti-yan">
        </link>
        <updated>2019-06-02T11:06:29.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>XCore 是一个动态跨平台框架。类似 RN，Weex。一次编写，多端运行是我们的目标。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>XCore 是一个动态跨平台框架。类似 RN，Weex。一次编写，多端运行是我们的目标。</p>
<!-- more --> 
<h2 id="技术方案">技术方案</h2>
<h3 id="选型">选型</h3>
<ol>
<li>客户端使用 js 解析引擎，对加载过来的js进行解析，并绑定原生的代码，通过原生代码来实现界面的绘制，事件的传递等。</li>
<li>说说选型。
<ol>
<li>前端基础库，我们选择了 Vue。Vue 非常适合移动界面的开发，现在已经越来越普及。选择 Vue，可以减少前端同学的学习成本。</li>
<li>安卓端解析引擎，使用谷歌提供的 V8 引擎。chrome 浏览器就在使用 V8 引擎对js进行引擎，解析速度很快。</li>
<li>iOS端，没有选择，只能使用jscore。这个是由于平台所限制的。</li>
</ol>
</li>
<li>谈谈排版。我们选择了 flex 排版。不了解的同学可以先行谷歌。flex排版方式，非常适合native端解析，而且容易使用。所需要支持的特性较少，但是功能强大。</li>
<li>功能实现。我们是标准 web api 的一个子集。一个为特定业务场景而生的微浏览器内核。</li>
</ol>
<h3 id="架构">架构</h3>
<h4 id="最上层我们提供web标准的子集dom操作的子集css的子集h5api的子集以及所需的事件">最上层我们提供Web标准的子集，DOM操作的子集，CSS的子集，H5API的子集，以及所需的事件</h4>
<p>我们使用的是标准的CSS规范，在Web端是直接使用的。Native端，在DOM Tree，每个Node有自己的Style属性，当Node被创建或者变成dirty的时候，会触发排版计算。
排版计算主要输出就是元素的位置和大小，随后元素的位置和大小的信息会被同步到Shadow Tree上，Shadow Tree在适当的时机将位置与大小的信息设置的Native Tree上对应的Native View的属性上，最终一次布局完成。</p>
<ul>
<li>为什么是在合适的时机，而不是立即的设置Native Tree呢？因为Native View的场景不是在DOM node创建的时候立即创建的。普通的Node是在attach时候才创建Native View，而在ListView的场景，是在对用Item系统通知需要创建的时候创建的</li>
<li>好处是，内核更加灵活。因为都是标准的Web API，能相对容易的接入各种前端框架，不用被单一的开发框架限定死。</li>
<li>理论上，我们可以接入任何前端框架，当然我们不是一个大而全的浏览器内核，不能提供完善的API，所以接入的改造成本还是难免。</li>
</ul>
<h4 id="渲染层面我们支持一份代码三端运行在web和native端我们都有不同的实现">渲染层面我们支持一份代码三端运行，在web和native端我们都有不同的实现</h4>
<ul>
<li>Native的渲染模型，三棵树，两个线程：这个渲染模型分为三棵树，DOM Tree, Shadow Tree，Native Tree。
<ul>
<li>DOM Tree：可以理解为标准浏览器中的DOM Tree，前端可以通过标准的API进行构建、操作。DOM Tree分两部分：在JS虚拟机里面有一层JS DOM的wrapper，方便我们对DOM的操作管控。
在Native层面是真正的DOM Tree实现，JS DOM Wrapper与Native DOM是严格的一一映射
排版在Native DOM上执行，这样能保证DOM的API操作都是实时的。</li>
<li>Shadow Tree可以理解为DOM Tree在 UI线程的映射，用于同步数据与操作到UI线程；为了提高性能，对数据同步我们是有批处理的。</li>
<li>Native Tree：对应的是Native UI组件构建出来的Tree，负责真正的渲染；在Android和iOS分别使用相应的UI Framework。</li>
</ul>
</li>
<li>优势
<ul>
<li>Web上，由于我们是标准的子集，可以直接运行。</li>
<li>Native端，我们是复用系统原生的渲染能力，这样才能保证页面达到原生级别的体验。</li>
</ul>
</li>
</ul>
<h4 id="扩展能力的建设-提供扩展机制方便native开发人员提供对应的native组件">扩展能力的建设。提供扩展机制，方便native开发人员提供对应的native组件</h4>
<p>我们提供常用的基础标签，如 view, label, image, input 等。在基础标签的基础上我们提供扩展组件的能力：</p>
<ul>
<li>一类就是自定义组件，用于弥补基础标签的不足。这个要求要有三端实现。自定义组件适合去复用已有的相对通用的Native组件，比如轮播图。对性能实时性要求较高的场景也个很好的弥补，如下拉刷新。</li>
<li>另外一类扩展是插件，我们完整的支持Cordova插件，复用原有的40+Cordova插件</li>
</ul>
<h4 id="调试工具">调试工具</h4>
<p>由于不断的推广，使用人员也越来越多，调试问题亟待解决。在安卓和iOS端通过对对应的js解析引擎的调研，发现其都有自己对应的调试协议。我们通过封装调试协议，在本机通过一个nodejs脚本开启调试服务，将解析引擎的信息通过这个服务进行中转，服务将消息统一处理为浏览器使用的调试协议，通过websocket发送给浏览器，然后在浏览器的操作会发送到此服务上，再进行转换，发送到对应的解析引擎，实现调试功能。目前已经具有：断点调试，console输出，dom实时高亮，浏览器展示设备界面，变量输入等功能。</p>
<h4 id="基础功能复用">基础功能复用</h4>
<p>我们大量复用了以后App架构的基础设施，如果图片，网络，日志统计等等，Web版的页面在App也是使用Web容器，其他离线化，开关，数据收集等都是复用Web容器的功能。同时，我们还提供了配套的编译、集成的工具。</p>
<h2 id="总结">总结</h2>
<p>个人经历的第一个框架开发，框架开发确实需要考虑诸多因素。在高速的迭代中，也成长了许多。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[国内安卓浏览器调研]]></title>
        <id>https://lybvinci.github.io/post/guo-nei-an-zhuo-liu-lan-qi-diao-yan</id>
        <link href="https://lybvinci.github.io/post/guo-nei-an-zhuo-liu-lan-qi-diao-yan">
        </link>
        <updated>2019-06-02T11:06:03.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="0x00-现状">0x00 现状</h2>
<p>先取几个排名吧：）（全部搜索关键字浏览器）</p>
<p>来自应用宝默认排名：</p>
<ol>
<li>QQ浏览器 （24亿下载）</li>
<li>百度 （22.4亿下载）</li>
<li>UC浏览器 （12亿次下载）</li>
<li>搜狗浏览器 （1.3亿次下载）</li>
<li>猎豹 （1.1亿）</li>
<li>傲游5 （603万次）</li>
<li>百度极速版 （4537.4次）</li>
<li>谷歌浏览器 （5488万次）</li>
<li>e浏览器 （226万次）</li>
<li>百度浏览器 （1.7亿次）</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h2 id="0x00-现状">0x00 现状</h2>
<p>先取几个排名吧：）（全部搜索关键字浏览器）</p>
<p>来自应用宝默认排名：</p>
<ol>
<li>QQ浏览器 （24亿下载）</li>
<li>百度 （22.4亿下载）</li>
<li>UC浏览器 （12亿次下载）</li>
<li>搜狗浏览器 （1.3亿次下载）</li>
<li>猎豹 （1.1亿）</li>
<li>傲游5 （603万次）</li>
<li>百度极速版 （4537.4次）</li>
<li>谷歌浏览器 （5488万次）</li>
<li>e浏览器 （226万次）</li>
<li>百度浏览器 （1.7亿次）</li>
</ol>
<!-- more --> 
<p>再看一下酷安应用市场按下载量排名：</p>
<ol>
<li>Chrome 浏览器 （737万次下载）</li>
<li>UC 浏览器 （467万次）</li>
<li>Via 浏览器 （399万次）</li>
<li>夸克浏览器 （219万次）</li>
<li>qq浏览器 （217万次）</li>
<li>VC 浏览器 （157万次）</li>
<li>X 浏览器 （147万次）</li>
<li>火狐浏览器（89万次）</li>
<li>Opera浏览器 （59万次）</li>
<li>海豚浏览器国际版 （53万次）</li>
</ol>
<h2 id="0x01-具体分析">0x01 具体分析</h2>
<h3 id="qq浏览器">QQ浏览器</h3>
<ul>
<li>优势：QQ浏览器有qq和微信加持，而且腾讯王卡免流，自然而然成为下载量第一的浏览器。</li>
<li>劣势：广告太多，打扰用户过多，体积臃肿。</li>
</ul>
<h3 id="uc浏览器">UC浏览器</h3>
<ul>
<li>优势：支付宝加持，阿里鱼卡免流。老牌浏览器，从塞班一直发展到现在。可谓历史悠久。移动端适配做的很好，去页面广告插件等完善，功能比较齐全。</li>
<li>劣势：丧心病狂的广告，被阿里收购之后，加上chrome发展之后， 就没什么优势了。</li>
</ul>
<h3 id="chrome-浏览器">chrome 浏览器</h3>
<ul>
<li>优势：chrome 浏览器是桌面端的霸主，在国外移动端也是霸主。更新速度快，业界标杆。</li>
<li>劣势：但是在国内，由于一些原因，账号同步不能用，并没有流行。而且大家已经习惯国产的浏览器界面，对于chrome的界面会比较排斥，觉得难用。所以中国用户相对较少。</li>
</ul>
<h3 id="via-浏览器">via 浏览器</h3>
<ul>
<li>优势：体积小，仅500k左右。功能强大，有脚本插件等功能。</li>
<li>劣势：没有大公司背景，只在极客之间流传。</li>
</ul>
<p>还有其他的浏览器，有些是在图片下载上有重点，各种图片都能下载（实际会有侵权等行为），或者有些是无论是什么文本都能自由复制，或者就是强大的去广告，看一些不可描述的东西，或者界面创新，简单易用。都比较有自己的优势。无疑，他们都是基于chromium内核打造的。速度上并没有什么特别大的差别。</p>
<p>还有很重要的一点，实际绝大多数用户，他们都在使用系统自带的浏览器。除非被捆绑安装，大多数用户都是使用自带浏览器。UC前期也是跟手机厂商合作才推广起来的。</p>
<h2 id="0x02-个人分析">0x02 个人分析</h2>
<p>看了上面的背景，应该可以有一些了解。如果仅仅依赖技术上的优化，速度上的提升，根本没法占用市场。用户并没有特别高的性能，打开速度。极大多数人，只要不是慢的太过分，都可以接受。各大浏览器比下来，没有一个是因为自己打开页面快而占有市场的。大家都是基于chromium，差别没有特别大。就算有20%-30%的速度提升，用户其实感知不出来的，几十毫秒，对于人眼来说，几乎可以忽略。所以怎么才能显示出自己的独特性，让大家都用我们的浏览器？以下几点个人想法：</p>
<ul>
<li>WebAR VR。好像别的浏览器也有，但是不是主打特色。</li>
<li>AI 做一些AI相关的事情。</li>
<li>依托头条大流量？定制免流卡？</li>
<li>各位大佬看看？</li>
</ul>
<h2 id="0x03-最后">0x03 最后</h2>
<p>浏览器先机已经被占了，但还是有一些机会，好的创意总会占有市场。大家的意见是什么呢？</p>
]]></content>
    </entry>
</feed>